キーワードやクリエイターで検索


109
メニュー
 投稿

あなただけに表示されています
見出し画像を設定してみませんか?
見出し画像があると、もっと作品のイメージが伝わります！
かんたんにオリジナル画像を作ったり、他のクリエイターが提供した画像から選んだりすることもできます。
ぜひ活用してみましょう！


新人エンジニア向け：Jenkins Job種類完全ガイド + システム時間取得実践

YUKIKO@BI＆AIを極めたい（転職活動中スカウト歓迎）
YUKIKO@BI＆AIを極めたい（転職活動中スカウト歓迎）
2025年10月24日 08:09



目次
📋 目次
Jenkins Jobとは
典型的なJobの流れ
💡 補足：Artifactとは？
Jenkins Jobの種類
1. Freestyle Project（フリースタイル）
📝 特徴
✅ メリット
❌ デメリット
🎯 こんな時に使う
📊 実例
💡 Freestyle Projectの構成要素
2. Pipeline（パイプライン）
📝 特徴
✅ メリット
❌ デメリット
🎯 こんな時に使う
📊 Pipelineの視覚化
💡 Pipelineの2つの書き方
3. Multibranch Pipeline（マルチブランチパイプライン）
📝 特徴
✅ メリット
❌ デメリット
🎯 こんな時に使う
📊 ブランチ戦略の例
実践：システム時間取得で3つ全部作る
🔨 パターン1: Freestyle Projectでシステム時間取得
ステップ1: 新規Job作成
ステップ2: General設定
ステップ3: ビルドトリガー（オプション）
ステップ4: ビルド手順
ステップ5: ビルド後の処理
ステップ6: 保存＆実行
🔨 パターン2: Pipelineでシステム時間取得
方法A: Classic UI（初心者向け）
方法B: SCMから取得（推奨・本番向け）
🔨 パターン3: Multibranch Pipelineでシステム時間取得
ステップ1: リポジトリ準備
ステップ2: ブランチ作成
ステップ3: Jenkins設定
ステップ4: Branch Sources設定
ステップ5: Build Configuration
ステップ6: Scan設定
ステップ7: 実行確認
📊 3つのパターンの実行結果比較
Freestyle Project
Pipeline
Multibranch Pipeline
作成日: 2025年10月24日
対象者: 新人エンジニア
難易度: 初級〜中級

📋 目次
Jenkins Jobとは

Freestyle Project（フリースタイル）

Pipeline（パイプライン）

Multibranch Pipeline（マルチブランチパイプライン）

3つの比較表

実践：システム時間取得で3つ全部作る

Jenkins Jobとは
Jenkins Jobとは、Jenkinsが自動的に実行する一連のタスクのことです。

典型的なJobの流れ
1. Gitリポジトリから最新コードを取得
   ↓
2. コードをビルド・コンパイル
   ↓
3. テストを実行（ユニットテスト、統合テストなど）
   ↓
4. 成果物（Artifact）を作成
   ↓
5. 結果を通知（Slack、メールなど）

copy
💡 補足：Artifactとは？
Artifact（アーティファクト） = ビルドで作成された、実際にデプロイする「モノ」

例：

.jarファイル（Javaアプリケーション）

.warファイル（Webアプリケーション）

Dockerイメージ

.zipファイル（圧縮されたアプリケーション）

Helmチャート（Kubernetes用）

Jenkins Jobの種類
Jenkinsには主に3つのJobタイプがあります：

タイプ 用途 難易度
Freestyle Project シンプルな1回限りのタスク ⭐ 初心者向け
Pipeline 複雑なCI/CDフロー ⭐⭐ 中級者向け
Multibranch Pipeline 複数ブランチの自動管理 ⭐⭐⭐ 上級者向け

1. Freestyle Project（フリースタイル）
📝 特徴
最もシンプルで柔軟なJobタイプ

GUIで設定できる（コードを書く必要がない）

1つのタスクを実行するのに最適

✅ メリット
初心者でも簡単に設定できる

GUIで全て完結

すぐに始められる

プラグインの機能を簡単に利用できる

❌ デメリット
複雑なワークフローには不向き

複数のステップを可視化できない

設定をコードで管理できない（バージョン管理が困難）

手動承認ステップを作れない

並列実行ができない

🎯 こんな時に使う
単純なビルドとテストを実行したい

すぐに試したいプロジェクトがある

学習目的で基本を理解したい

1回限りのタスクを実行したい

📊 実例
シナリオ： Gitからコードを取得して、ビルドして、テストを実行する

ステップ1: Git checkout
ステップ2: mvn clean install （ビルド）
ステップ3: mvn test （テスト実行）
ステップ4: メールで結果を通知

copy
💡 Freestyle Projectの構成要素
1. General（一般設定）

ビルド履歴の管理

✓ 古いビルドの破棄
  保存するビルドの最大数: 10
  保存する成果物の最大数: 5

copy
プロジェクトの設定

□ このプロジェクトを無効化（一時的に停止したい場合）
□ 並行ビルド（同時に複数のビルドを実行）

copy
2. ソースコード管理

Gitの設定例：

Repository URL: https://github.com/username/project.git
Credentials: github-token
Branch: */main

copy
3. ビルドトリガー

いつビルドを開始するか？

トリガー 説明 使用例 GitHubにプッシュされたらビルド コミット毎に自動ビルド CI（継続的インテグレーション） 定期的にビルド Cron形式で定期実行 毎日深夜にビルド SCMをポーリング 定期的にGitをチェック Webhookが使えない場合 他のプロジェクト後にビルド JobをChain化 Job A → Job B

Cron形式の例：

# 毎日午前2時
0 2 * * *

# 毎時0分
0 * * * *

# 平日の午前9時
0 9 * * 1-5

copy
4. ビルド環境

よく使う設定：

✓ ビルド開始前にワークスペースを削除
✓ タイムスタンプをコンソール出力に追加
✓ ビルドのタイムアウト（例：30分）

copy
5. ビルド

実際のビルドコマンド：

Shellスクリプトの例：

#!/bin/bash
echo "ビルド開始"
mvn clean install
mvn test
echo "ビルド完了"

copy
6. ビルド後の処理

ビルド成功後にできること：

✓ メール通知
✓ Slack通知
✓ テストレポートの公開
✓ 成果物のアーカイブ
✓ 次のJobをトリガー
✓ 自動デプロイ

copy
2. Pipeline（パイプライン）
📝 特徴
コードでCI/CDフローを定義（Jenkinsfile）

複数のステージを可視化できる

バージョン管理できる（Infrastructure as Code）

✅ メリット
視覚化できる：どのステップで失敗したか一目瞭然

コードで管理：Gitでバージョン管理できる

手動承認：本番デプロイ前に承認ステップを入れられる

並列実行：複数のテストを同時に実行できる

再利用可能：同じコードを複数のプロジェクトで使える

耐久性：Jenkins再起動後も処理を継続できる

❌ デメリット
Groovy言語の知識が必要（学習コストがある）

初期設定がFreestyleより複雑

デバッグが難しい場合がある

🎯 こんな時に使う
本格的なCI/CDパイプラインを構築したい

複数のステージ（ビルド→テスト→デプロイ）がある

手動承認が必要（本番デプロイ前など）

並列実行でビルド時間を短縮したい

Infrastructure as Codeを実践したい

📊 Pipelineの視覚化
[ビルド] → [テスト] → [ステージング] → [承認] → [本番デプロイ]
   ↓          ↓           ↓              ↓          ↓
 成功       成功        成功          待機中      成功

copy
💡 Pipelineの2つの書き方
Declarative Pipeline（宣言型・推奨）

特徴：

構造化されていて読みやすい

初心者向け

エラーチェックが自動

基本構造：

pipeline {
    agent any
    
    stages {
        stage('ビルド') {
            steps {
                echo 'ビルド中...'
                sh 'mvn clean install'
            }
        }
        
        stage('テスト') {
            steps {
                echo 'テスト実行中...'
                sh 'mvn test'
            }
        }
        
        stage('デプロイ') {
            steps {
                echo 'デプロイ中...'
                sh './deploy.sh'
            }
        }
    }
    
    post {
        success {
            echo 'ビルド成功！'
        }
        failure {
            echo 'ビルド失敗...'
        }
    }
}

copy
Scripted Pipeline（スクリプト型）

特徴：

より柔軟で高度な制御が可能

上級者向け

Groovyの知識が必要

基本構造：

node {
    stage('ビルド') {
        echo 'ビルド中...'
        sh 'mvn clean install'
    }
    
    stage('テスト') {
        echo 'テスト実行中...'
        sh 'mvn test'
    }
    
    stage('デプロイ') {
        echo 'デプロイ中...'
        sh './deploy.sh'
    }
}

copy
3. Multibranch Pipeline（マルチブランチパイプライン）
📝 特徴
複数のブランチを自動的に管理

各ブランチに対して自動的にPipelineを作成

ブランチ毎に異なるJenkinsfileを使える

✅ メリット
自動ブランチ検出：新しいブランチを自動認識

プルリクエスト対応：PRごとにビルド・テスト

ブランチ戦略に対応：Git Flow、GitHub Flowなど

自動クリーンアップ：削除されたブランチのJobも自動削除

❌ デメリット
設定が最も複雑

リソース消費が大きい（ブランチ数に比例）

初心者には理解が難しい

🎯 こんな時に使う
複数の開発ブランチがある

プルリクエスト毎にテストしたい

Git Flow戦略を採用している

チーム開発で各メンバーのブランチをテストしたい

📊 ブランチ戦略の例
main ────────────────────────────────
        ↓                    ↑
develop ────────────────────────
         ↓            ↑
feature/login ────────
         ↓        ↑
feature/payment ──

copy
それぞれのブランチで自動的にビルド・テストが実行される！

実践：システム時間取得で3つ全部作る
システム時間を取得するスクリプトで、3つのJobタイプ全てを実際に作ってみましょう！

🔨 パターン1: Freestyle Projectでシステム時間取得
ステップ1: 新規Job作成
Jenkinsダッシュボードを開く

「新規ジョブ作成」 をクリック

ジョブ名: SystemTime-Freestyle

「フリースタイル・プロジェクトのビルド」 を選択

「OK」

ステップ2: General設定
✓ 古いビルドの破棄
  保存するビルドの最大数: 10

copy
ステップ3: ビルドトリガー（オプション）
✓ 定期的に実行
  スケジュール: 0 * * * *  （毎時0分に実行）

copy
ステップ4: ビルド手順
「ビルド手順の追加」 → 「シェルの実行」

コピペ用コード：

#!/bin/bash

echo "=========================================="
echo "システム時間取得スクリプト (Freestyle)"
echo "=========================================="
echo ""

echo "📋 Jenkins情報"
echo "  ビルド番号: ${BUILD_NUMBER}"
echo "  ジョブ名: ${JOB_NAME}"
echo "  ビルドID: ${BUILD_ID}"
echo "  ワークスペース: ${WORKSPACE}"
echo ""

echo "⏰ システム時間情報"
echo "----------------------------------------"
echo "  現在日時: $(date '+%Y年%m月%d日 %H時%M分%S秒')"
echo "  ISO形式: $(date '+%Y-%m-%d %H:%M:%S')"
echo "  ファイル名用: $(date '+%Y%m%d_%H%M%S')"
echo "  UNIXタイム: $(date +%s)"
echo "  曜日: $(date '+%A')"
echo "  タイムゾーン: $(date +%Z)"
echo ""

echo "💻 システム情報"
echo "----------------------------------------"
echo "  ホスト名: $(hostname)"
echo "  ユーザー: $(whoami)"
echo "  OS: $(uname -s)"
echo ""

# ログディレクトリ作成
mkdir -p logs

# ログファイル作成
TIMESTAMP=$(date '+%Y%m%d_%H%M%S')
LOG_FILE="logs/freestyle_${TIMESTAMP}.log"

cat > "$LOG_FILE" <<EOF
========================================
Freestyle Project - システム時間ログ
========================================
実行日時: $(date '+%Y-%m-%d %H:%M:%S')
ビルド番号: ${BUILD_NUMBER}
ジョブ名: ${JOB_NAME}
ホスト: $(hostname)
ユーザー: $(whoami)
----------------------------------------
UNIXタイムスタンプ: $(date +%s)
タイムゾーン: $(date +%Z)
========================================
EOF

echo "✅ ログファイル作成完了"
echo "  場所: $LOG_FILE"
echo ""
cat "$LOG_FILE"
echo ""
echo "🎉 Freestyle Project 実行完了！"

copy
ステップ5: ビルド後の処理
「ビルド後の処理の追加」 → 「成果物の保管」

保管する成果物: logs/*.log

copy
ステップ6: 保存＆実行
「保存」

「ビルド実行」

「コンソール出力」 で確認

「ビルド成果物」 からログをダウンロード

🔨 パターン2: Pipelineでシステム時間取得
方法A: Classic UI（初心者向け）
ステップ1: 新規Job作成

「新規ジョブ作成」

ジョブ名: SystemTime-Pipeline

「Pipeline」 を選択

「OK」

ステップ2: Pipeline設定

「Pipeline」 セクションまでスクロール

Definition: Pipeline script

コピペ用コード：

pipeline {
    agent any
    
    stages {
        stage('システム情報取得') {
            steps {
                script {
                    echo '=========================================='
                    echo 'システム時間取得スクリプト (Pipeline)'
                    echo '=========================================='
                    echo ''
                    
                    echo '📋 Jenkins情報'
                    echo "  ビルド番号: ${env.BUILD_NUMBER}"
                    echo "  ジョブ名: ${env.JOB_NAME}"
                    echo "  ビルドURL: ${env.BUILD_URL}"
                    echo ''
                }
            }
        }
        
        stage('時間情報表示') {
            steps {
                sh '''
                    echo "⏰ システム時間情報"
                    echo "----------------------------------------"
                    echo "  現在日時: $(date '+%Y年%m月%d日 %H時%M分%S秒')"
                    echo "  ISO形式: $(date '+%Y-%m-%d %H:%M:%S')"
                    echo "  UNIXタイム: $(date +%s)"
                    echo "  曜日: $(date '+%A')"
                    echo ""
                '''
            }
        }
        
        stage('ログ作成') {
            steps {
                sh '''
                    mkdir -p logs
                    TIMESTAMP=$(date '+%Y%m%d_%H%M%S')
                    LOG_FILE="logs/pipeline_${TIMESTAMP}.log"
                    
                    cat > "$LOG_FILE" <<EOF
========================================
Pipeline - システム時間ログ
========================================
実行日時: $(date '+%Y-%m-%d %H:%M:%S')
ビルド番号: ${BUILD_NUMBER}
ジョブ名: ${JOB_NAME}
ホスト: $(hostname)
----------------------------------------
UNIXタイムスタンプ: $(date +%s)
========================================
EOF
                    
                    echo "✅ ログファイル作成: $LOG_FILE"
                    cat "$LOG_FILE"
                '''
            }
        }
    }
    
    post {
        success {
            echo '🎉 Pipeline実行成功！'
            archiveArtifacts artifacts: 'logs/*.log', allowEmptyArchive: true
        }
        failure {
            echo '❌ Pipeline実行失敗'
        }
        always {
            echo '=========================================='
            echo 'Pipeline実行完了'
            echo '=========================================='
        }
    }
}

copy
ステップ3: 保存＆実行

「保存」

「ビルド実行」

Stage View でステージごとの進捗を確認

方法B: SCMから取得（推奨・本番向け）
ステップ1: Gitリポジトリ準備

リポジトリのルートに Jenkinsfile を作成

Jenkinsfile（コピペ用）：

pipeline {
    agent any
    
    stages {
        stage('Checkout') {
            steps {
                echo 'リポジトリからコードを取得...'
                checkout scm
            }
        }
        
        stage('システム情報取得') {
            steps {
                script {
                    echo '=========================================='
                    echo 'システム時間取得 (Pipeline from SCM)'
                    echo '=========================================='
                    echo ''
                    
                    echo '📋 Jenkins情報'
                    echo "  ビルド番号: ${env.BUILD_NUMBER}"
                    echo "  ジョブ名: ${env.JOB_NAME}"
                    echo "  ブランチ: ${env.GIT_BRANCH}"
                    echo ''
                }
            }
        }
        
        stage('時間情報表示') {
            steps {
                sh '''
                    echo "⏰ システム時間情報"
                    echo "  現在日時: $(date '+%Y年%m月%d日 %H時%M分%S秒')"
                    echo "  UNIXタイム: $(date +%s)"
                    echo ""
                '''
            }
        }
        
        stage('ログ作成') {
            steps {
                sh '''
                    mkdir -p logs
                    TIMESTAMP=$(date '+%Y%m%d_%H%M%S')
                    LOG_FILE="logs/pipeline_scm_${TIMESTAMP}.log"
                    
                    cat > "$LOG_FILE" <<EOF
========================================
Pipeline (SCM) - システム時間ログ
========================================
実行日時: $(date)
ビルド番号: ${BUILD_NUMBER}
========================================
EOF
                    
                    echo "✅ ログ作成: $LOG_FILE"
                '''
            }
        }
    }
    
    post {
        success {
            archiveArtifacts artifacts: 'logs/*.log', allowEmptyArchive: true
            echo '🎉 成功！'
        }
    }
}

copy
ステップ2: Gitにコミット

git add Jenkinsfile
git commit -m "Add: Pipeline Jenkinsfile"
git push origin main

copy
ステップ3: Jenkins設定

「新規ジョブ作成」

ジョブ名: SystemTime-Pipeline-SCM

「Pipeline」 選択

「OK」

Pipeline セクション設定：

Definition: Pipeline script from SCM

SCM: Git

Repository URL: https://github.com/yourusername/repo.git

Credentials: 認証情報を選択

Branch: */main

Script Path: Jenkinsfile

「保存」 → 「ビルド実行」

🔨 パターン3: Multibranch Pipelineでシステム時間取得
ステップ1: リポジトリ準備
複数ブランチを作成し、それぞれに Jenkinsfile を配置

mainブランチ用 Jenkinsfile

pipeline {
    agent any
    
    stages {
        stage('Info') {
            steps {
                echo "=========================================="
                echo "Multibranch Pipeline - システム時間取得"
                echo "=========================================="
                echo "ブランチ: ${env.BRANCH_NAME}"
                echo "ビルド番号: ${env.BUILD_NUMBER}"
                echo ""
            }
        }
        
        stage('時間取得') {
            steps {
                sh '''
                    echo "⏰ 現在時刻: $(date '+%Y-%m-%d %H:%M:%S')"
                    echo "📦 ブランチ: ${BRANCH_NAME}"
                '''
            }
        }
        
        stage('本番環境処理') {
            when {
                branch 'main'
            }
            steps {
                echo '🚀 本番環境用の処理を実行'
                sh '''
                    mkdir -p logs
                    echo "本番環境ログ: $(date)" > logs/production_$(date +%Y%m%d_%H%M%S).log
                '''
            }
        }
        
        stage('開発環境処理') {
            when {
                branch 'develop'
            }
            steps {
                echo '🔧 開発環境用の処理を実行'
                sh '''
                    mkdir -p logs
                    echo "開発環境ログ: $(date)" > logs/development_$(date +%Y%m%d_%H%M%S).log
                '''
            }
        }
        
        stage('機能ブランチ処理') {
            when {
                branch pattern: "feature/.*", comparator: "REGEXP"
            }
            steps {
                echo '🌿 機能ブランチの処理を実行'
                sh '''
                    mkdir -p logs
                    echo "機能ブランチログ: $(date)" > logs/feature_$(date +%Y%m%d_%H%M%S).log
                '''
            }
        }
    }
    
    post {
        success {
            archiveArtifacts artifacts: 'logs/*.log', allowEmptyArchive: true
            echo "✅ ${env.BRANCH_NAME} ブランチ: ビルド成功"
        }
    }
}

copy
ステップ2: ブランチ作成
# mainブランチ
git add Jenkinsfile
git commit -m "Add: Multibranch Jenkinsfile"
git push origin main

# developブランチ作成
git checkout -b develop
git push origin develop

# featureブランチ作成
git checkout -b feature/time-display
git push origin feature/time-display

copy
ステップ3: Jenkins設定
「新規ジョブ作成」

ジョブ名: SystemTime-Multibranch

「Multibranch Pipeline」 選択

「OK」

ステップ4: Branch Sources設定
「Branch Sources」 → 「Add source」 → 「Git」

設定：

Project Repository: https://github.com/yourusername/repo.git

Credentials: 認証情報を選択

ステップ5: Build Configuration
「Build Configuration」

Mode: by Jenkinsfile

Script Path: Jenkinsfile

ステップ6: Scan設定
「Scan Multibranch Pipeline Triggers」

✓ Periodically if not otherwise run

Interval: 1 minute（テスト用）

「保存」

ステップ7: 実行確認
自動的にブランチスキャンが開始

検出されたブランチ：

main

develop

feature/time-display

それぞれのブランチで自動的にビルドが実行される

📊 3つのパターンの実行結果比較
Freestyle Project
Started by user admin
Building in workspace /var/jenkins/workspace/SystemTime-Freestyle
[SystemTime-Freestyle] $ /bin/bash
==========================================
システム時間取得スクリプト (Freestyle)
==========================================
📋 Jenkins情報
  ビルド番号: 5
  ジョブ名: SystemTime-Freestyle
⏰ システム時間情報
  現在日時: 2025年10月24日 14時30分45秒
✅ ログファイル作成完了
🎉 Freestyle Project 実行完了！
Finished: SUCCESS

copy
Pipeline
Started by user admin
[Pipeline] Start of Pipeline
[Pipeline] stage (システム情報取得)
[Pipeline] echo
📋 Jenkins情報
  ビルド番号: 3
[Pipeline] stage (時間情報表示)
⏰ システム時間情報
  現在日時: 2025年10月24日 14時31分12秒
[Pipeline] stage (ログ作成)
✅ ログファイル作成
[Pipeline] echo
🎉 Pipeline実行成功！
[Pipeline] End of Pipeline
Finished: SUCCESS

copy
Multibranch Pipeline
Branch indexing
Checking branches...
  Checking branch main
    'Jenkinsfile' found
  Checking branch develop
    'Jenkinsfile' found
  Checking branch feature/time-display
    'Jenkinsfile' found
Processed 3 branches

copy








YUKIKO@BI＆AIを極めたい（転職活動中スカウト歓迎）
YUKIKO@BI＆AIを極めたい（転職活動中スカウト歓迎）
生成AIパスポート試験合格に向けて学習中！
Python3エンジニア認定試験合格
2025年7月：BIの学習中です！

【技術】
Python/Django/スクレイピング/業務自動化







noteプレミアム
note pro
よくある質問・noteの使い方
プライバシー
クリエイターへのお問い合わせ
フィードバック
ご利用規約
通常ポイント利用特約
加盟店規約
資⾦決済法に基づく表⽰
特商法表記
投資情報の免責事項
新人エンジニア向け：Jenkins Job種類完全ガイド + システム時間取得実践｜YUKIKO@BI＆AIを極めたい（転職活動中スカウト歓迎）
